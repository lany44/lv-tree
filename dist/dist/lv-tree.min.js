"use strict";
var defineProperty = function defineProperty(e, r, n) {
  return r in e ? Object.defineProperty(e, r, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = n, e;
},
    _extends = Object.assign || function (e) {
  for (var r = 1; r < arguments.length; r++) {
    var n = arguments[r];for (var t in n) {
      Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    }
  }return e;
},
    toConsumableArray = function toConsumableArray(e) {
  if (Array.isArray(e)) {
    for (var r = 0, n = Array(e.length); r < e.length; r++) {
      n[r] = e[r];
    }return n;
  }return Array.from(e);
},
    PreOrder = "PreOrder",
    PostOrder = "PostOrder",
    genTraverseTreeListFunc = function genTraverseTreeListFunc(e) {
  return function (r, n) {
    return r.forEach(function (r) {
      return function r(t) {
        e === PreOrder && n(t), t.children && t.children.length > 0 && t.children.forEach(function (e) {
          return r(e);
        }), e === PostOrder && n(t);
      }(r);
    }), r;
  };
},
    preOrderTreeList = genTraverseTreeListFunc(PreOrder),
    deepClone = function e(r, n) {
  if (Object(r) !== r || r instanceof Function) return r;if (n.has(r)) return n.get(r);var t = void 0;try {
    t = new r.constructor();
  } catch (e) {
    t = Object.create(Object.getPrototypeOf(r));
  }return n.set(r, t), Object.assign.apply(Object, [t].concat(toConsumableArray(Object.keys(r).map(function (t) {
    return defineProperty({}, t, e(r[t], n));
  }))));
},
    cloneTreeList = function cloneTreeList(e) {
  var r = [],
      n = new WeakMap();return n.set(e, r), e.forEach(function (e) {
    return r.push(deepClone(e, n));
  }), r;
},
    LvTreeNode = { render: function render() {
    var e = this,
        r = e.$createElement,
        n = e._self._c || r;return n("div", { staticClass: "lv-tree-node", class: { "is-root": !e.node.$$parent, "is-last-child": e.isLastChild } }, [n("div", { staticClass: "node-el", class: { "is-root": !e.node.$$parent, "is-first-child": e.isFirstChild, "extended-horizontal": !e.hasChildren } }, [n("div", { staticClass: "change-fold" }, [e.hasChildren ? e._t("fold-icon") : e._e()], 2), e._v(" "), n("div", { class: { "is-dragging": e.node.$$isDragging, "is-dragging-over": e.node.$$isDraggingOver }, attrs: { draggable: e.options.enableDrag }, on: { dragstart: function dragstart(r) {
          e.onDragStart(e.node);
        }, dragend: function dragend(r) {
          e.onDragEnd(e.node);
        }, dragenter: function dragenter(r) {
          r.preventDefault(), e.onDragOver(e.node);
        }, dragover: function dragover(r) {
          r.preventDefault(), e.onDragOver(e.node);
        }, dragleave: function dragleave(r) {
          e.onDragLeave(e.node);
        }, drop: function drop(r) {
          e.onDrop(e.node);
        } } }, [e._t("content")], 2)]), e._v(" "), e.isFold ? e._e() : n("div", { staticClass: "child-tree-wrap" }, [e._t("children")], 2)]);
  }, staticRenderFns: [], name: "LvTreeNode", props: { node: { type: Object, required: !0 }, options: { type: Object, default: function _default() {} } }, computed: { isLastChild: function isLastChild() {
      var e = this.node.$$parent,
          r = this.node;return e && e.children[e.children.length - 1] === r;
    }, isFirstChild: function isFirstChild() {
      var e = this.node.$$parent,
          r = this.node;return e && e.children[0] === r;
    }, hasChildren: function hasChildren() {
      return this.node.children.length > 0;
    }, isFold: function isFold() {
      return this.node.$$isFold;
    } }, methods: { changeFold: function changeFold() {
      this.node.$$isFold = !this.node.$$isFold;
    }, onDragStart: function onDragStart(e) {
      preOrderTreeList([e], function (e) {
        return e.$$isDragging = !0;
      }), this.$emit("drag", e);
    }, onDragEnd: function onDragEnd(e) {
      preOrderTreeList([e], function (e) {
        return e.$$isDragging = !1;
      });
    }, onDragOver: function onDragOver(e) {
      e.$$isDragging || (e.$$isDraggingOver = !0);
    }, onDragLeave: function onDragLeave(e) {
      e.$$isDraggingOver = !1;
    }, onDrop: function onDrop(e) {
      e.$$isDraggingOver = !1, this.$emit("drop", e);
    } } },
    renderChildTree = { props: { data: Array, options: Object, scopedSlots: Object, listeners: Object }, render: function render(e) {
    var r = this.data,
        n = this.options,
        t = this.scopedSlots,
        o = this.listeners;return e("lv-tree", { props: { data: r, options: n }, scopedSlots: t, on: _extends({}, o) });
  } },
    Uid = 0,
    DraggingNode = null,
    lvTree = { render: function render() {
    var e = this,
        r = e.$createElement,
        n = e._self._c || r;return n("div", { staticClass: "lv-tree-wrap" }, [n("ul", { staticClass: "lv-tree", class: { root: e.isRoot } }, e._l(e.renderData, function (r) {
      return n("li", { key: r.$$uid, staticClass: "tree-node" }, [n("lv-tree-node", { attrs: { node: r, options: e.options }, on: { drag: e.onDrag, drop: e.onDrop } }, [n("template", { slot: "fold-icon" }, [e._t("fold-icon", null, { node: r, parent: r.$$parent })], 2), e._v(" "), n("template", { slot: "content" }, [e._t("default", null, { node: r, parent: r.$$parent })], 2), e._v(" "), e.hasChildren(r) ? n("renderChildTree", { attrs: { slot: "children", options: e.options, data: r.children, "scoped-slots": e.$scopedSlots, listeners: e.$listeners }, slot: "children" }) : e._e()], 2)], 1);
    }))]);
  }, staticRenderFns: [], _scopeId: "data-v-1ec5e5b8", name: "LvTree", components: { LvTreeNode: LvTreeNode, renderChildTree: renderChildTree }, props: { data: { type: Array, default: function _default() {
        return [];
      } }, options: { type: Object, default: function _default() {
        return { enableDrag: !1, foldDeep: null };
      } } }, computed: { isRoot: function isRoot() {
      return this.data.length > 0 && this.data.every(function (e) {
        return !e.$$parent;
      });
    }, renderData: function renderData() {
      var e = this,
          r = e.isRoot,
          n = e.data,
          t = void 0 === n ? [] : n,
          o = e.options.foldDeep,
          i = void 0 === o ? null : o,
          a = t;if (r) {
        a.forEach(function (r) {
          return function r(n, o, a) {
            if (e.$set(n, "$$uid", Uid++), e.$set(n, "$$rootData", t), e.$set(n, "$$isDragging", !1), e.$set(n, "$$isDraggingOver", !1), e.$set(n, "$$deep", o), e.$set(n, "$$parent", a), "boolean" == typeof n.$$isFold) {
              var s = n.$$isFold;delete n.$$isFold, e.$set(n, "$$isFold", s);
            } else e.$set(n, "$$isFold", !!i && Boolean(n.$$deep >= i));0 !== n.children.length && n.children.forEach(function (e) {
              return r(e, o + 1, n);
            });
          }(r, 1, null);
        });
      }return a;
    } }, methods: { hasChildren: function hasChildren(e) {
      return e.children && e.children.length > 0;
    }, onDrag: function onDrag(e) {
      DraggingNode = e;
    }, onDrop: function onDrop(e) {
      if (!e.$$isDragging && DraggingNode.$$parent !== e) {
        var r = cloneTreeList(DraggingNode.$$rootData),
            n = void 0,
            t = void 0;preOrderTreeList(r, function (r) {
          r.$$uid === DraggingNode.$$uid && (n = r), r.$$uid === e.$$uid && (t = r), r.$$isDragging = !1, r.$$isDraggingOver = !1;
        });var o = n.$$parent ? n.$$parent.children : n.$$rootData;o.splice(o.indexOf(n), 1), n.$$parent = t, n.$$deep = t.$$deep + 1, t.children.push(n), this.$emit("drag", { dragNode: n, dropNode: t, afterData: r }), DraggingNode = null;
      }
    } } },
    index = { install: function install(e) {
    e.component("lv-tree", lvTree);
  } };module.exports = index;
//# sourceMappingURL=lv-tree.min.js.map